{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { Group } from '@vx/group';\nimport { tree, treemap, cluster, pack, partition } from 'd3-hierarchy';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nHierarchyDefaultLink.propTypes = {\n  link: PropTypes.object\n};\n\nfunction HierarchyDefaultLink(_ref) {\n  var link = _ref.link;\n  return React.createElement(\"line\", {\n    x1: link.source.x,\n    y1: link.source.y,\n    x2: link.target.x,\n    y2: link.target.y,\n    strokeWidth: 2,\n    stroke: \"#999\",\n    strokeOpacity: 0.6\n  });\n}\n\nHierarchyDefaultNode.propTypes = {\n  node: PropTypes.object\n};\n\nfunction HierarchyDefaultNode(_ref) {\n  var node = _ref.node;\n  return React.createElement(\"circle\", {\n    cx: node.x,\n    cy: node.y,\n    r: 15,\n    fill: \"#21D4FD\"\n  });\n}\n\nTree.propTypes = {\n  root: PropTypes.object.isRequired,\n  children: PropTypes.func,\n  top: PropTypes.number,\n  left: PropTypes.number,\n  className: PropTypes.string,\n  size: PropTypes.arrayOf(PropTypes.number),\n  nodeSize: PropTypes.arrayOf(PropTypes.number),\n  separation: PropTypes.func,\n  linkComponent: PropTypes.any,\n  nodeComponent: PropTypes.any\n};\n\nfunction Tree(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      size = _ref.size,\n      nodeSize = _ref.nodeSize,\n      separation = _ref.separation,\n      children = _ref.children,\n      _ref$linkComponent = _ref.linkComponent,\n      linkComponent = _ref$linkComponent === void 0 ? HierarchyDefaultLink : _ref$linkComponent,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === void 0 ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = _objectWithoutProperties(_ref, [\"top\", \"left\", \"className\", \"root\", \"size\", \"nodeSize\", \"separation\", \"children\", \"linkComponent\", \"nodeComponent\"]);\n\n  var tree$$1 = tree();\n  if (size) tree$$1.size(size);\n  if (nodeSize) tree$$1.nodeSize(nodeSize);\n  if (separation) tree$$1.separation(separation);\n  var data = tree$$1(root);\n  if (children) return children(data);\n  return React.createElement(Group, {\n    top: top,\n    left: left,\n    className: cx('vx-tree', className)\n  }, linkComponent && data.links().map(function (link, i) {\n    return React.createElement(Group, {\n      key: \"tree-link-\".concat(i)\n    }, React.createElement(linkComponent, {\n      link: link\n    }));\n  }), nodeComponent && data.descendants().map(function (node, i) {\n    return React.createElement(Group, {\n      key: \"tree-node-\".concat(i)\n    }, React.createElement(nodeComponent, {\n      node: node\n    }));\n  }));\n}\n\nTreemap.propTypes = {\n  root: PropTypes.object.isRequired,\n  children: PropTypes.func,\n  top: PropTypes.number,\n  left: PropTypes.number,\n  className: PropTypes.string,\n  tile: PropTypes.func,\n  size: PropTypes.arrayOf(PropTypes.number),\n  round: PropTypes.bool,\n  padding: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  paddingInner: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  paddingOuter: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  paddingTop: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  paddingRight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  paddingBottom: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  paddingLeft: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n  nodeComponent: PropTypes.any\n};\n\nfunction Treemap(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      tile = _ref.tile,\n      size = _ref.size,\n      round = _ref.round,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      paddingTop = _ref.paddingTop,\n      paddingRight = _ref.paddingRight,\n      paddingBottom = _ref.paddingBottom,\n      paddingLeft = _ref.paddingLeft,\n      children = _ref.children,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === void 0 ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = _objectWithoutProperties(_ref, [\"top\", \"left\", \"className\", \"root\", \"tile\", \"size\", \"round\", \"padding\", \"paddingInner\", \"paddingOuter\", \"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\", \"children\", \"nodeComponent\"]);\n\n  var treemap$$1 = treemap();\n  if (tile) treemap$$1.tile(tile);\n  if (size) treemap$$1.size(size);\n  if (round) treemap$$1.round(round);\n  if (padding) treemap$$1.padding(padding);\n  if (paddingInner) treemap$$1.paddingInner(paddingInner);\n  if (paddingOuter) treemap$$1.paddingOuter(paddingOuter);\n  if (paddingTop) treemap$$1.paddingTop(paddingTop);\n  if (paddingRight) treemap$$1.paddingRight(paddingRight);\n  if (paddingBottom) treemap$$1.paddingBottom(paddingBottom);\n  if (paddingLeft) treemap$$1.paddingLeft(paddingLeft);\n  var data = treemap$$1(root);\n  if (children) return children(data);\n  return React.createElement(Group, {\n    top: top,\n    left: left,\n    className: cx('vx-treemap', className)\n  }, nodeComponent && data.descendants().map(function (node, i) {\n    return React.createElement(Group, {\n      key: \"treemap-node-\".concat(i)\n    }, React.createElement(nodeComponent, {\n      node: node\n    }));\n  }));\n}\n\nCluster.propTypes = {\n  root: PropTypes.object.isRequired,\n  children: PropTypes.func,\n  top: PropTypes.number,\n  left: PropTypes.number,\n  className: PropTypes.string,\n  size: PropTypes.arrayOf(PropTypes.number),\n  nodeSize: PropTypes.arrayOf(PropTypes.number),\n  separation: PropTypes.func,\n  linkComponent: PropTypes.any,\n  nodeComponent: PropTypes.any\n};\n\nfunction Cluster(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      size = _ref.size,\n      nodeSize = _ref.nodeSize,\n      separation = _ref.separation,\n      children = _ref.children,\n      _ref$linkComponent = _ref.linkComponent,\n      linkComponent = _ref$linkComponent === void 0 ? HierarchyDefaultLink : _ref$linkComponent,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === void 0 ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = _objectWithoutProperties(_ref, [\"top\", \"left\", \"className\", \"root\", \"size\", \"nodeSize\", \"separation\", \"children\", \"linkComponent\", \"nodeComponent\"]);\n\n  var cluster$$1 = cluster();\n  if (size) cluster$$1.size(size);\n  if (nodeSize) cluster$$1.nodeSize(nodeSize);\n  if (separation) cluster$$1.separation(separation);\n  var data = cluster$$1(root);\n  if (children) return children(data);\n  return React.createElement(Group, {\n    top: top,\n    left: left,\n    className: cx('vx-cluster', className)\n  }, linkComponent && data.links().map(function (link, i) {\n    return React.createElement(Group, {\n      key: \"cluster-link-\".concat(i)\n    }, React.createElement(linkComponent, {\n      link: link\n    }));\n  }), nodeComponent && data.descendants().map(function (node, i) {\n    return React.createElement(Group, {\n      key: \"cluster-node-\".concat(i)\n    }, React.createElement(nodeComponent, {\n      node: node\n    }));\n  }));\n}\n\nPack.propTypes = {\n  root: PropTypes.object.isRequired,\n  children: PropTypes.func,\n  top: PropTypes.number,\n  left: PropTypes.number,\n  className: PropTypes.string,\n  radius: PropTypes.func,\n  size: PropTypes.arrayOf(PropTypes.number),\n  padding: PropTypes.number,\n  nodeComponent: PropTypes.any\n};\n\nfunction Pack(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      radius = _ref.radius,\n      size = _ref.size,\n      padding = _ref.padding,\n      children = _ref.children,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === void 0 ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = _objectWithoutProperties(_ref, [\"top\", \"left\", \"className\", \"root\", \"radius\", \"size\", \"padding\", \"children\", \"nodeComponent\"]);\n\n  var pack$$1 = pack();\n  if (size) pack$$1.size(size);\n  if (radius !== undefined) pack$$1.radius(radius);\n  if (padding) pack$$1.padding(padding);\n  var data = pack$$1(root);\n  if (children) return children(data);\n  return React.createElement(Group, {\n    top: top,\n    left: left,\n    className: cx('vx-pack', className)\n  }, nodeComponent && data.descendants().map(function (node, i) {\n    return React.createElement(Group, {\n      key: \"pack-node-\".concat(i)\n    }, React.createElement(nodeComponent, {\n      node: node\n    }));\n  }));\n}\n\nPartition.propTypes = {\n  root: PropTypes.object.isRequired,\n  children: PropTypes.func,\n  top: PropTypes.number,\n  left: PropTypes.number,\n  className: PropTypes.string,\n  size: PropTypes.arrayOf(PropTypes.number),\n  round: PropTypes.bool,\n  padding: PropTypes.number,\n  nodeComponent: PropTypes.any\n};\n\nfunction Partition(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      size = _ref.size,\n      round = _ref.round,\n      padding = _ref.padding,\n      children = _ref.children,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === void 0 ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = _objectWithoutProperties(_ref, [\"top\", \"left\", \"className\", \"root\", \"size\", \"round\", \"padding\", \"children\", \"nodeComponent\"]);\n\n  var partition$$1 = partition();\n  if (size) partition$$1.size(size);\n  if (round) partition$$1.round(round);\n  if (padding) partition$$1.padding(padding);\n  var data = partition$$1(root);\n  if (children) return children(data);\n  return React.createElement(Group, {\n    top: top,\n    left: left,\n    className: cx('vx-partition', className)\n  }, nodeComponent && data.descendants().map(function (node, i) {\n    return React.createElement(Group, {\n      key: \"partition-node-\".concat(i)\n    }, React.createElement(nodeComponent, {\n      node: node\n    }));\n  }));\n}\n\nexport { Tree, Treemap, Cluster, Pack, Partition, HierarchyDefaultLink, HierarchyDefaultNode };","map":null,"metadata":{},"sourceType":"module"}